    GET stm32_EQU.s

; Объявляем макроподстановку для максимального размера массива
MAXmas EQU 0xA

; Объявляем сегмент констант
    AREA CONSTANT_FLASH, DATA, READONLY

; Объявляем наш произвольный массив
mas1 DCB -128, -13, 0, 17, 59, 11, 0, -6, 36, 255 ; от -128 до 255
;        |         |       |      |       |
mas2 DCB -128, -13, 0, 17, 59, 11, 0, -6, 36, 255
; Объявляем сегмент переменных
    AREA VERIABLE_RAM, DATA, READWRITE

; Инициализация переменной, в которой будет храниться результат
result SPACE 0x01

; Объявляем сегмент кода 
    AREA MAIN, CODE, READONLY
    THUMB

; Объявляем функцию main 
main PROC
    LDR R3, =mas1
    B main_fun1  ; Наша функция fun1
    
main_fun1
    ; Обнуляем регистры, в которых будем хранить переменные
    MOV R0, #NULL ; R0 = i
    MOV R1, #NULL ; R1 = a
    MOV R2, #NULL ; R2 = n
    
Suda1 ; Метка сюда1
    ; Проверим условие, i > максимального размера массива?
    ; CMP заполняет флаги. Работает вот так: MAXas-i, если i равно или больше
    ; 10 то мы перестаем работать с BLT и переходим к безусловному переходу
    CMP R0, #MAXmas
    
    ; Если выполняется условие то переходим в CALC1. Условие: i должно быть
    ; меньше MAXmas и не равно ему
    BLT CALC1 ; Переход при выполнении условия <
    B CALC3 ; На почти выход, если не выполняется условие

CALC1 ; Метка калькулятор1
    ; Запишем в регистр R4 значение массива, адрес которого указан в регистре R3
    ; Также следует учесть смещение записанное в регистре R0
    LDRB R4, [R3, R0] ; R4 = mas[i]
    SXTB R4, R4 ; Размножаем знак 8 бит до 32 бит, чтобы работать с отриц. значениями
    ADD R0, #TWO ; R0 = R0 + 2. Идем по четным индексам
    ; Сравниваем значение массива с NULL
    CMP R4, #NULL
    
    ; Если R4 > 0 то значит оно положительное и не нулевое. Переходим в CALC2
    BGT CALC2
    
    ; Если не удолетворяет условию, то обратно в сюда1
    B Suda1
    
CALC2 ; Метка калькулятор2
    ADD R1, R4 ; Накапливаем сумму
    ADD R2, #ONE ; Считаем положительные числа
    B Suda1 ; Возращаемся назад в Suda1 за остальной частью массива

CALC3 ; Метка калькулятор3
    UDIV R0, R1, R2 ; Находим среднее арифметическое значение

    LDR R1, =result ; Записываем адрес переменной result в регистр R1
    STRB R0, [R1] ; Записываем значение регистра R0 в память по адресу, который записан в регистре R1

loop
    B loop      ; Бесконечный цикл нужен для того, чтобы не переходить к 
                ; константам, потому что они в конце программы сохраняются
    ENDP ; Конец функции main
    END  ; Конец файла